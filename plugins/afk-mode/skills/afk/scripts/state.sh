#!/bin/bash
# AFK Mode State Management
# Handles reading/writing AFK state in JSON format
#
# State file: ~/.claude/afk-mode/state.json
# Session log: ~/.claude/afk-mode/sessions/{session_id}.jsonl

set -e

# Check for jq dependency
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed." >&2
    echo "Install with: brew install jq (macOS) or apt install jq (Linux)" >&2
    exit 1
fi

STATE_DIR="$HOME/.claude/afk-mode"
STATE_FILE="$STATE_DIR/state.json"
SESSIONS_DIR="$STATE_DIR/sessions"
PLANS_DIR="$STATE_DIR/plans"

# Ensure directories exist
ensure_dirs() {
    mkdir -p "$STATE_DIR" "$SESSIONS_DIR" "$PLANS_DIR"
}

# Get current state (returns JSON or empty object if not enabled)
get_state() {
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo '{}'
    fi
}

# Check if AFK mode is enabled
is_enabled() {
    if [ -f "$STATE_FILE" ]; then
        local enabled=$(jq -r '.enabled // false' "$STATE_FILE" 2>/dev/null)
        [ "$enabled" = "true" ] && return 0
    fi
    return 1
}

# Get current mode (full, plan, research, monitor)
get_mode() {
    if [ -f "$STATE_FILE" ]; then
        jq -r '.mode // "full"' "$STATE_FILE" 2>/dev/null
    else
        echo "full"
    fi
}

# Get AFK message
get_message() {
    local default_msg="I am away from keyboard. Please plan as much as you can without tool use or questions. Only stop when you definitely need my input or permission to proceed."
    if [ -f "$STATE_FILE" ]; then
        local msg
        msg=$(jq -r '.message // empty' "$STATE_FILE" 2>/dev/null)
        if [ -n "$msg" ]; then
            echo "$msg"
        else
            echo "$default_msg"
        fi
    else
        echo "$default_msg"
    fi
}

# Get session ID
get_session_id() {
    if [ -f "$STATE_FILE" ]; then
        jq -r '.session_id // ""' "$STATE_FILE" 2>/dev/null
    fi
}

# Enable AFK mode
# Usage: enable_afk <mode> <message> [session_id] [context_json]
enable_afk() {
    ensure_dirs
    local mode="${1:-full}"
    local default_msg="I am away from keyboard. Please plan as much as you can without tool use or questions. Only stop when you definitely need my input or permission to proceed."
    local message="${2:-$default_msg}"
    local session_id="${3:-$(date +%Y%m%d_%H%M%S)}"
    local timestamp=$(date -Iseconds)

    # Escape message for JSON using jq
    local escaped_message
    escaped_message=$(printf '%s' "$message" | jq -Rs '.')

    # Write state file with proper JSON
    cat > "$STATE_FILE" << EOFSTATE
{
  "enabled": true,
  "mode": "$mode",
  "message": ${escaped_message},
  "session_id": "$session_id",
  "started_at": "$timestamp",
  "context": {},
  "stats": {
    "tools_blocked": 0,
    "tools_allowed": 0,
    "stop_events": 0
  }
}
EOFSTATE

    # Initialize session log
    echo '{"event":"session_start","timestamp":"'"$timestamp"'","mode":"'"$mode"'"}' > "$SESSIONS_DIR/$session_id.jsonl"

    # Initialize planning document
    cat > "$PLANS_DIR/$session_id.md" << EOF
# AFK Planning Session - $session_id

**Started**: $timestamp
**Mode**: $mode
**Message**: $message

---

## Planned Actions

<!-- Actions Claude planned but couldn't execute -->

## Blocked Tool Calls

<!-- Tools that were blocked during AFK mode -->

## Decisions Needed

<!-- Questions/decisions that require user input -->

## Notes

<!-- Claude's analysis and observations -->

---

*This document is auto-generated by AFK Mode Plugin*
EOF

    echo "$STATE_FILE"
}

# Disable AFK mode
disable_afk() {
    if [ -f "$STATE_FILE" ]; then
        local session_id=$(get_session_id)
        local timestamp=$(date -Iseconds)

        # Log session end
        if [ -n "$session_id" ] && [ -f "$SESSIONS_DIR/$session_id.jsonl" ]; then
            echo '{"event":"session_end","timestamp":"'"$timestamp"'"}' >> "$SESSIONS_DIR/$session_id.jsonl"
        fi

        # Archive state with end time
        if [ -n "$session_id" ]; then
            jq --arg ended "$timestamp" '. + {enabled: false, ended_at: $ended}' "$STATE_FILE" > "$STATE_DIR/archive_$session_id.json" 2>/dev/null || true
        fi

        rm -f "$STATE_FILE"
        echo "disabled"
    else
        echo "not_enabled"
    fi
}

# Log a blocked tool call
# Usage: log_blocked <tool_name> <tool_input_json> <reason>
log_blocked() {
    local tool_name="$1"
    local tool_input="$2"
    local reason="$3"
    local session_id=$(get_session_id)
    local timestamp=$(date -Iseconds)

    if [ -n "$session_id" ] && [ -f "$SESSIONS_DIR/$session_id.jsonl" ]; then
        # Log to session file
        jq -n \
            --arg event "tool_blocked" \
            --arg ts "$timestamp" \
            --arg tool "$tool_name" \
            --argjson input "$tool_input" \
            --arg reason "$reason" \
            '{event: $event, timestamp: $ts, tool: $tool, input: $input, reason: $reason}' \
            >> "$SESSIONS_DIR/$session_id.jsonl"

        # Update stats
        if [ -f "$STATE_FILE" ]; then
            local count=$(jq '.stats.tools_blocked // 0' "$STATE_FILE")
            jq --argjson c "$((count + 1))" '.stats.tools_blocked = $c' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"
        fi

        # Append to planning document
        if [ -f "$PLANS_DIR/$session_id.md" ]; then
            echo "" >> "$PLANS_DIR/$session_id.md"
            echo "### [$timestamp] Blocked: $tool_name" >> "$PLANS_DIR/$session_id.md"
            echo '```json' >> "$PLANS_DIR/$session_id.md"
            echo "$tool_input" | jq '.' >> "$PLANS_DIR/$session_id.md" 2>/dev/null || echo "$tool_input" >> "$PLANS_DIR/$session_id.md"
            echo '```' >> "$PLANS_DIR/$session_id.md"
        fi
    fi
}

# Log a stop event
log_stop() {
    local reason="$1"
    local session_id=$(get_session_id)
    local timestamp=$(date -Iseconds)

    if [ -n "$session_id" ] && [ -f "$SESSIONS_DIR/$session_id.jsonl" ]; then
        echo '{"event":"stop","timestamp":"'"$timestamp"'","reason":"'"$reason"'"}' >> "$SESSIONS_DIR/$session_id.jsonl"

        # Update stats
        if [ -f "$STATE_FILE" ]; then
            local count=$(jq '.stats.stop_events // 0' "$STATE_FILE")
            jq --argjson c "$((count + 1))" '.stats.stop_events = $c' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"
        fi
    fi
}

# Get tools allowed for current mode
get_allowed_tools() {
    local mode=$(get_mode)
    case "$mode" in
        full)
            echo ""  # No tools allowed
            ;;
        plan)
            echo "Read,Glob,Grep"  # Read-only
            ;;
        research)
            echo "Read,Glob,Grep,WebFetch,WebSearch"  # Read + web
            ;;
        monitor)
            echo "Read,Glob,Grep,Bash"  # Read + safe bash (filtered)
            ;;
        *)
            echo ""
            ;;
    esac
}

# Check if a tool is allowed in current mode
is_tool_allowed() {
    local tool_name="$1"
    local allowed=$(get_allowed_tools)

    if [ -z "$allowed" ]; then
        return 1  # No tools allowed
    fi

    echo "$allowed" | grep -qw "$tool_name"
}

# Get current session's planning document path
get_plan_path() {
    local session_id=$(get_session_id)
    if [ -n "$session_id" ]; then
        echo "$PLANS_DIR/$session_id.md"
    fi
}

# Get current session log path
get_session_log_path() {
    local session_id=$(get_session_id)
    if [ -n "$session_id" ]; then
        echo "$SESSIONS_DIR/$session_id.jsonl"
    fi
}

# Main command dispatcher
case "${1:-}" in
    get-state)      get_state ;;
    is-enabled)     is_enabled && echo "true" || echo "false" ;;
    get-mode)       get_mode ;;
    get-message)    get_message ;;
    get-session-id) get_session_id ;;
    enable)         enable_afk "$2" "$3" "$4" "$5" ;;
    disable)        disable_afk ;;
    log-blocked)    log_blocked "$2" "$3" "$4" ;;
    log-stop)       log_stop "$2" ;;
    get-allowed)    get_allowed_tools ;;
    is-allowed)     is_tool_allowed "$2" && echo "true" || echo "false" ;;
    get-plan-path)  get_plan_path ;;
    get-log-path)   get_session_log_path ;;
    *)
        echo "Usage: state.sh <command> [args]"
        echo "Commands: get-state, is-enabled, get-mode, get-message, enable, disable, log-blocked, log-stop, get-allowed, is-allowed, get-plan-path, get-log-path"
        exit 1
        ;;
esac
